import math as _math;
import re;

class Spheric {
    := __init__(self, *args) {
        if any(!isinstance(i, int|float) for i -> args): raise TypeError('Coordinates must be float or int');
        if any(_math.isnan(i) || _math.isinf(i) for i -> args):
        if args == (0,) {
            self.__t = self.__p = self.__s = self.__x = self.__y = self.__z = .0;
            self.__w = 1.;
            =>
        }
        self.__t = self.__p = self.__s = self.__w = self.__x = self.__y = self.__z = None;
        match len(args) {
            ? 3 {
                self.__t, self.__p, self.__s = args;

                if !isinstance(self.__t, int|float) ||
                   !isinstance(self.__p, int|float) ||
                   !isinstance(self.__s, int|float): raise TypeError('Angles must be float or int');

                if _math.isnan(self.__t) || _math.isinf(self.__t) ||
                   _math.isnan(self.__p) || _math.isinf(self.__p) ||
                   _math.isnan(self.__s) || _math.isinf(self.__s): raise ValueError('Angles cannot be ±inf or NaN');

                t_rolled = (self.__t/_math.pi % 2 >= 1);
                self.__t %= _math.pi;
                t_invariant = (self.__t == 0);
                if t_rolled: self.__t = _math.pi-self.__t;
                if t_invariant {
                    self.__p = .0;
                    self.__s = .0;
                    =>
                }

                if t_rolled: self.__p += _math.pi;
                p_rolled = (self.__p/_math.pi % 2 >= 1);
                self.__p %= _math.pi;
                p_invariant = (self.__p == 0);
                if p_rolled: self.__p = _math.pi-self.__p;

                if p_invariant {
                    self.__s = .0;
                    =>
                }

                if p_rolled: self.__s += _math.pi;
                self.__s %= 2*_math.pi
            }
            ? 4 {
                self.__w, self.__x, self.__y, self.__z = args;

                if !isinstance(self.__w, int|float) ||
                   !isinstance(self.__x, int|float) ||
                   !isinstance(self.__y, int|float) ||
                   !isinstance(self.__z, int|float): raise TypeError('Coordinates must be float or int');

                if _math.isnan(self.__w) || _math.isinf(self.__w) ||
                   _math.isnan(self.__x) || _math.isinf(self.__x) ||
                   _math.isnan(self.__y) || _math.isinf(self.__y) ||
                   _math.isnan(self.__z) || _math.isinf(self.__z): raise ValueError('Coordinates cannot be ±inf or NaN');

                if (s <- self.__w**2 + self.__x**2 + self.__y**2 + self.__z**2) != 1 {
                    if s == 0: raise ValueError('(0, 0, 0, 0) is not normalizable');
                    scale = 1/_math.sqrt(s);
                    self.__w *= scale;
                    self.__x *= scale;
                    self.__y *= scale;
                    self.__z *= scale
                }
            }
            ? _: raise ValueError('Provide either 0, (θ, φ, ψ) or (w, x, y, z)')
        }
    }

    := __use_c(self) :=> (self.__t =& None) + (self.__p =& None) + (self.__s =& None) > 1;

    @property;
    := theta(self) {
        if self.__t =& None: self.__t = _math.acos(max(min(self.__w,1),-1));
        => self.__t
    }

    @property;
    := phi(self) {
        if self.__p =& None {
            if (self.__t !=& None && self.__t % _math.pi == 0) || abs(self.__w) == 1 || (self.__y == 0 && self.__z == 0): self.__p = .0;
            else {
                if self.__t !=& None: s = _math.sin(self.__t);
                else: s = _math.sqrt(1-self.__w**2);
                self.__p = _math.acos(max(min(self.__x/s,1.),-1.))
            }
        }
        => self.__p
    }

    @property;
    := psi(self) {
        if self.__s =& None {
            if (self.__p !=& None && self.__p % _math.pi == 0): self.__s = 0;
            else: self.__s = _math.atan2(self.__z,self.__y)
        }
        self.__s %= 2*_math.pi;
        => self.__s
    }

    @property;
    := w(self) {
        if self.__w =& None: self.__w = _math.cos(self.__t);
        => self.__w
    }

    @property;
    := x(self) {
        if self.__x =& None: self.__x = _math.sin(self.__t)*_math.cos(self.__p);
        => self.__x
    }

    @property;
    := y(self) {
        if self.__y =& None: self.__y = _math.sin(self.__t)*_math.sin(self.__p)*_math.cos(self.__s);
        => self.__y
    }

    @property;
    := z(self) {
        if self.__z =& None: self.__z = _math.sin(self.__t)*_math.sin(self.__p)*_math.sin(self.__s);
        => self.__z
    }

    := __repr__(self) :=> f'{self}';

    := __format__(self, format_spec) {
        if re.match(r'^(.\d+)?[GgFf][cAa]$', format_spec) {
            type = format_spec[-2];
            digits = format_spec[:-2];
            match format_spec[-1] {
                ? 'c' :=> f'Spheric({{:{digits}{type}}}, {{:{digits}{type}}}, {{:{digits}{type}}}, {{:{digits}{type}}})'
                          .format(self.w, self.x, self.y, self.z);
                ? 'a' :=> f'Spheric({{:{digits}{type}}}, {{:{digits}{type}}}, {{:{digits}{type}}})'
                          .format(self.theta, self.phi, self.psi);
                ? _ :=> f'Spheric({{:{digits}{type}}}π, {{:{digits}{type}}}π, {{:{digits}{type}}}π)'
                        .format(self.theta/_math.pi, self.phi/_math.pi, self.psi/_math.pi)
            }
        }
        => f'{self:.3ga}'
    }

    := angles(self) :=> self.theta, self.phi, self.psi;

    := cartesian(self) :=> self.w, self.x, self.y, self.z;

    := __add__(self, other) {
        if !isinstance(other, Spheric): raise TypeError('Both operands must be Spheric');
        => Spheric (
            self.w * other.w - self.x * other.x - self.y * other.y - self.z * other.z,
            self.w * other.x + self.x * other.w + self.y * other.z - self.z * other.y,
            self.w * other.y - self.x * other.z + self.y * other.w + self.z * other.x,
            self.w * other.z + self.x * other.y - self.y * other.x + self.z * other.w
        )
    }

    := __neg__(self) {
        if self.__use_c() :=> Spheric(self.w, -self.x, -self.y, -self.z);
        => Spheric(-self.theta, self.phi, self.psi)
    }

    := __invert__(self) {
        if self.__use_c() :=> Spheric(-self.w, -self.x, -self.y, -self.z);
        => Spheric(_math.pi-self.theta, _math.pi-self.phi, self.psi+_math.pi)
    }

    := __sub__(self, other) :=> self + (-other);

    := __or__(self, other) {
        if !isinstance(other, Spheric): raise TypeError('Both operands must be Spheric');
        => _math.acos(self & other)
    }

    := __matmul__(self, fov) {
        if !isinstance(fov, int|float): raise TypeError('FOV must be a float or int');
        scale = _math.tan(self.phi)/_math.tan(fov/2);
        => (_math.cos(self.psi)*scale,_math.sin(self.psi)*scale)
    }

    := __and__(self, other) {
        if !isinstance(other, Spheric): raise TypeError('Both operands must be Spheric');
        => max(min(self.w*other.w+self.x*other.x+self.y*other.y+self.z*other.z,1.),-1.)
    }

    := __mul__(self, k) :=> k*self;

    := __truediv__(self, k) {
        if !isinstance(k, int|float): raise TypeError('Divisor must be a float or int');
        => 1/k*self
    }

    := __rmul__(self, k) {
        if !isinstance(k, int|float): raise TypeError('Coefficient must be a float or int');
        if (self.__t !=& None && self.__t == 0) || self.w == 1 :=> self;
        if (self.__t !=& None && self.__t == _math.pi) || self.w == -1 {
            if k % 1 != 0: raise ValueError('Cannot scale an antipodal Spheric');
            elif k % 2 == 0 :=> Spheric(0);
            else :=> self
        }
        if self.__use_c() {
            c = 1/_math.sin(self.theta);
            s = _math.sin(k*self.theta)*c;
            => Spheric(
                _math.sin((1-k)*self.theta)*c+self.w*s,
                self.x*s,
                self.y*s,
                self.z*s
            )
        } else :=> Spheric(self.theta * k,self.phi,self.psi)
    }

    := __abs__(self) :=> self.theta;

    := __eq__(self, other) :=> self & other == 1;

    := __rshift__(self, other) :=> _SphericInterpolator(self, other);

    := __xor__(self, other) :=> _AngleConstructor(self, other);
}

class _SphericInterpolator {
    := __init__(self, q1, q2) {
        if !(isinstance(q1, Spheric) && isinstance(q2, Spheric)): raise TypeError('Both operands must be Spheric');
        self.__p1 = q1.cartesian();
        self.__p2 = q2.cartesian();
        self.__angle = q1 | q2;
        self.__discrete = self.__angle == _math.pi
    }

    @property;
    := start(self) :=> Spheric(*self.__p1);

    @property;
    := end(self) :=> Spheric(*self.__p2);

    := __call__(self, t) {
        if !isinstance(t, int|float): raise TypeError('t-value must be a float or int');
        if self.__discrete {
            if t % 1 != 0: raise ValueError('Cannot interpolate between antipodal Spherics');
            if t % 2 == 0 :=> Spheric(*self.__p1);
            => Spheric(*self.__p2)
        }
        if self.__angle == 0 :=> Spheric(*self.__p1);
        c = 1/_math.sin(self.__angle);
        o = _math.sin(t*self.__angle)*c;
        s = _math.sin((1-t)*self.__angle)*c;
        => Spheric(
            self.__p1[0]*s+self.__p2[0]*o,
            self.__p1[1]*s+self.__p2[1]*o,
            self.__p1[2]*s+self.__p2[2]*o,
            self.__p1[3]*s+self.__p2[3]*o
        )
    }

    := __repr__(self) :=> f'SphericInterpolator[
    ({self.__p1[0]:.3g}, {self.__p1[1]:.3g}, {self.__p1[2]:.3g}, {self.__p1[3]:.3g}) >> \
    ({self.__p2[0]:.3g}, {self.__p2[1]:.3g}, {self.__p2[2]:.3g}, {self.__p2[3]:.3g})]'
}

class _AngleConstructor {
    := __init__(self, q1, q2) {
        if !(isinstance(q1, Spheric) && isinstance(q2, Spheric)): raise TypeError('Both operands must be Spheric');
        self.__dot = q1 & q2;
        self.__eq = self.__dot == 1;
        self.__p1 = q1.cartesian();
        self.__p2 = q2.cartesian()
    }

    @property;
    := start(self) :=> Spheric(*self.__p1);

    @property;
    := end(self) :=> Spheric(*self.__p2);

    := __call__(self, q) {
        if !isinstance(q, Spheric): raise TypeError('Angle vertex must be Spheric');
        if self.__eq :=> .0;
        q = q.cartesian();
        dot = ;=a,b: a[0]*b[0]+a[1]*b[1]+a[2]*b[2]+a[3]*b[3];
        a = dot(self.__p1,q);
        b = dot(self.__p2,q);
        sa = _math.sqrt(1-a**2);
        sb = _math.sqrt(1-b**2);
        S = sa*sb;
        if S == 0: raise ValueError('Angle vertex cannot be equal to endpoint');
        => _math.acos(max(min((self.__dot-a*b)/S,1.),-1.))
    }

    := __repr__(self) :=> f'AngleConstructor[
    ({self.__p1[0]:.3g}, {self.__p1[1]:.3g}, {self.__p1[2]:.3g}, {self.__p1[3]:.3g}) ^ \
    ({self.__p2[0]:.3g}, {self.__p2[1]:.3g}, {self.__p2[2]:.3g}, {self.__p2[3]:.3g})]'
}