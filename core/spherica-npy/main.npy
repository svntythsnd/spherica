import math as _math;
import re;

class Spheric {
    := __init__(self, *args) {
        if args == (0,) {
            self._t = self._p = self._s = self._x = self._y = self._z = .0;
            self._w = 1.;
            =>
        }
        self._t = self._p = self._s = self._w = self._x = self._y = self._z = None;
        match len(args) {
            ? 3 {
                self._t = args[0];
                t_rolled = (self._t/_math.pi % 2 >= 1);
                self._t %= _math.pi;
                t_invariant = (self._t == 0);
                if t_rolled: self._t = _math.pi-self._t;
                if t_invariant {
                    self._p = .0;
                    self._s = .0;
                    =>
                }

                self._p = args[1];
                if t_rolled: self._p += _math.pi;
                p_rolled = (self._p/_math.pi % 2 >= 1);
                self._p %= _math.pi;
                p_invariant = (self._p == 0);
                if p_rolled: self._p = _math.pi-self._p;

                if p_invariant {
                    self._s = .0;
                    =>
                }

                self._s = args[2];
                if p_rolled: self._s += _math.pi;
                self._s %= 2*_math.pi
            }
            ? 4 {
                self._w, self._x, self._y, self._z = args;
                if (s <- self._w**2 + self._x**2 + self._y**2 + self._z**2) != 1 {
                    scale = 1/_math.sqrt(s);
                    self._w *= scale;
                    self._x *= scale;
                    self._y *= scale;
                    self._z *= scale
                }
            }
            ? _: raise ValueError('Provide either 0, (θ, φ, ψ) or (w, x, y, z)')
        }
    }

    := _use_c(self) :=> (self._t =& None) + (self._p =& None) + (self._s =& None) > 1;

    @property;
    := theta(self) {
        if self._t =& None: self._t = _math.acos(max(min(self._w,1),-1));
        => self._t
    }

    @property;
    := phi(self) {
        if self._p =& None {
            if (self._t !=& None && self._t % _math.pi == 0) || abs(self._w) == 1 || (self._y == 0 && self._z == 0): self._p = .0;
            else {
                if self._t !=& None: s = _math.sin(self._t);
                else: s = _math.sqrt(1-self._w**2);
                self._p = _math.acos(max(min(self._x/s,1),-1))
            }
        }
        => self._p
    }

    @property;
    := psi(self) {
        if self._s =& None {
            if (self._p !=& None && self._p % _math.pi == 0): self._s = 0;
            else: self._s = _math.atan2(self._z,self._y)
        }
        self._s %= 2*_math.pi;
        => self._s
    }

    @property;
    := w(self) {
        if self._w =& None: self._w = _math.cos(self._t);
        => self._w
    }

    @property;
    := x(self) {
        if self._x =& None: self._x = _math.sin(self._t)*_math.cos(self._p);
        => self._x
    }

    @property;
    := y(self) {
        if self._y =& None: self._y = _math.sin(self._t)*_math.sin(self._p)*_math.cos(self._s);
        => self._y
    }

    @property;
    := z(self) {
        if self._z =& None: self._z = _math.sin(self._t)*_math.sin(self._p)*_math.sin(self._s);
        => self._z
    }

    := __repr__(self) :=> f'{self}';

    := __format__(self, format_spec) {
        if re.match(r'^(.\d+)?[GgFf][cAa]$', format_spec) {
            type = format_spec[-2];
            digits = format_spec[:-2];
            match format_spec[-1] {
                ? 'c' :=> f'Spheric({{:{digits}{type}}}, {{:{digits}{type}}}, {{:{digits}{type}}}, {{:{digits}{type}}})'
                          .format(self.w, self.x, self.y, self.z);
                ? 'a' :=> f'Spheric({{:{digits}{type}}}, {{:{digits}{type}}}, {{:{digits}{type}}})'
                          .format(self.theta, self.phi, self.psi);
                ? _ :=> f'Spheric({{:{digits}{type}}}π, {{:{digits}{type}}}π, {{:{digits}{type}}}π)'
                        .format(self.theta/_math.pi, self.phi/_math.pi, self.psi/_math.pi)
            }
        }
        => f'{self:.3ga}'
    }

    := angles(self) :=> self.theta, self.phi, self.psi;

    := cartesian(self) :=> self.w, self.x, self.y, self.z;

    := __add__(self, other) {
        if !isinstance(other, Spheric): raise ValueError('Both operands must be Spheric');
        => Spheric (
            self.w * other.w - self.x * other.x - self.y * other.y - self.z * other.z,
            self.w * other.x + self.x * other.w + self.y * other.z - self.z * other.y,
            self.w * other.y - self.x * other.z + self.y * other.w + self.z * other.x,
            self.w * other.z + self.x * other.y - self.y * other.x + self.z * other.w
        )
    }

    := __neg__(self) {
        if self._use_c() :=> Spheric(self.w, -self.x, -self.y, -self.z);
        => Spheric(-self.theta, self.phi, self.psi)
    }

    := __invert__(self) {
        if self._use_c() :=> Spheric(-self.w, -self.x, -self.y, -self.z);
        => Spheric(_math.pi-self.theta, _math.pi-self.phi, self.psi+_math.pi)
    }

    := __sub__(self, other) {
        => self + (-other)
    }

    := __or__(self, other) {
        if !isinstance(other, Spheric): raise ValueError('Both operands must be Spheric');
        => _math.acos(self._dot(other))
    }

    := __matmul__(self, fov) {
        if !isinstance(fov, int|float): raise ValueError('FOV must be a float or int');
        scale = _math.tan(self.phi)/_math.tan(fov/2);
        => (_math.cos(self.psi)*scale,_math.sin(self.psi)*scale)
    }

    := __mul__(self, k) :=> k*self;

    := __truediv__(self, k) {
        if !isinstance(k, int|float): raise ValueError('Divisor must be a float or int');
        => 1/k*self
    }

    := __rmul__(self, k) {
        if (self._t !=& None && self._t == 0) || self.w == 1 :=> self;
        if !isinstance(k, int|float): raise ValueError('Coefficient must be a float or int');
        if (self._t !=& None && self._t == _math.pi) || self.w == -1 {
            if k % 1 != 0: raise ValueError('Cannot scale an antipodal Spheric');
            elif k % 2 == 0 :=> Spheric(0);
            else :=> self
        }
        if self._use_c() {
            c = 1/_math.sin(self.theta);
            s = _math.sin(k*self.theta)*c;
            => Spheric(
                _math.sin((1-k)*self.theta)*c+self.w*s,
                self.x*s,
                self.y*s,
                self.z*s
            )
        } else :=> Spheric(self.theta * k,self.phi,self.psi)
    }

    := _dot(self, other) :=> max(min(self.w*other.w+self.x*other.x+self.y*other.y+self.z*other.z,1),-1);

    := __abs__(self) :=> self.theta;

    := __eq__(self, other) :=> self._dot(other) == 1;

    := __rshift__(self, other) :=> _SphericInterpolator(self, other);

    := __xor__(self, other) :=> _AngleConstructor(self, other);
}

class _SphericInterpolator {
    := __init__(self, q1, q2) {
        if !(isinstance(q1, Spheric) && isinstance(q2, Spheric)): raise ValueError('Both operands must be Spheric');
        self._p1 = q1.cartesian();
        self._p2 = q2.cartesian();
        self._angle = q1 | q2;
        self._discrete = self._angle == _math.pi
    }

    @property;
    := start(self) :=> Spheric(*self._p1);

    @property;
    := end(self) :=> Spheric(*self._p2);

    := __call__(self, t) {
        if !isinstance(t, int|float): raise ValueError('t-value must be a float or int');
        if self._discrete {
            if t % 1 != 0: raise ValueError('Cannot interpolate between antipodal Spherics');
            if t % 2 == 0 :=> Spheric(*self._p1);
            => Spheric(*self._p2)
        }
        if self._angle == 0 :=> Spheric(*self._p1);
        c = 1/_math.sin(self._angle);
        o = _math.sin(t*self._angle)*c;
        s = _math.sin((1-t)*self._angle)*c;
        => Spheric(
            self._p1[0]*s+self._p2[0]*o,
            self._p1[1]*s+self._p2[1]*o,
            self._p1[2]*s+self._p2[2]*o,
            self._p1[3]*s+self._p2[3]*o
        )
    }

    := __repr__(self) :=> f'SphericInterpolator[
    ({self._p1[0]:.3g}, {self._p1[1]:.3g}, {self._p1[2]:.3g}, {self._p1[3]:.3g}) >> \
    ({self._p2[0]:.3g}, {self._p2[1]:.3g}, {self._p2[2]:.3g}, {self._p2[3]:.3g})]'
}

class _AngleConstructor {
    := __init__(self, q1, q2) {
        if !(isinstance(q1, Spheric) && isinstance(q2, Spheric)): raise ValueError('Both operands must be Spheric');
        self._dot = q1._dot(q2);
        self._eq = self._dot == 1;
        self._p1 = q1.cartesian();
        self._p2 = q2.cartesian()
    }

    @property;
    := start(self) :=> Spheric(*self._p1);

    @property;
    := end(self) :=> Spheric(*self._p2);

    := __call__(self, q) {
        if !isinstance(q, Spheric): raise ValueError('Angle vertex must be Spheric');
        if self._eq :=> .0;
        q = q.cartesian();
        dot = ;=a,b: a[0]*b[0]+a[1]*b[1]+a[2]*b[2]+a[3]*b[3];
        a = dot(self._p1,q);
        b = dot(self._p2,q);
        sa = _math.sqrt(1-a**2);
        sb = _math.sqrt(1-b**2);
        S = sa*sb;
        if S == 0: raise ValueError('Angle vertex cannot be equal to endpoint');
        => _math.acos(max(min((self._dot-a*b)/S,1),-1))
    }

    := __repr__(self) :=> f'AngleConstructor[
    ({self._p1[0]:.3g}, {self._p1[1]:.3g}, {self._p1[2]:.3g}, {self._p1[3]:.3g}) ^ \
    ({self._p2[0]:.3g}, {self._p2[1]:.3g}, {self._p2[2]:.3g}, {self._p2[3]:.3g})]'
}